---
title: Exploit The Heap
tags:
  - 系统安全
  - 内存安全
  - glibc
  - linux
date: 2016-12-12 21:40:00
---
### Glibc Heap结构  
在linux系统中，堆上的存储结构，是由**chunk**来定义的。
在glibc中，一个allocated chunk结构如下：

	   	chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if allocated            | |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk, in bytes                       |M|P|
      	mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             User data starts here...                          .
	    .                                                               .
	    .             (malloc_usable_size() bytes)                      .
	    .                                                               |
		nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk                                     |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    
每个chunck的前2个word，保存了前一个chunk的大小和当前chunk的大小。而mem则是实际返回的指针。这里BIT位表示的是这个chunk是否使用mmap来申请的。  
而一个freed chunk如下：

		
        chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |   'head:'          Size of chunk, in bytes                  |P|
      	mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
	    nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    	|   'foot:'          Size of chunk, in bytes                    |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    
free chunck被保存在一个环形的双向链表当中。这里BIT位P表示“PREV_INUSE”，表示**前一个**chunck是否正在被使用。如果这个位是'clear'，那么Size of previous chunk则包含前一个chunck的大小，能够用来找到前面一个chunk。否则，这个Size of previous chunk是无效的，不能用它来找到前一个chunk。  
而用来管理chunk的数据结构则是malloc_chunck:

	struct malloc_chunk {

  	INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  	INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  	struct malloc_chunk* fd;         /* double links -- used only if free. */
  	struct malloc_chunk* bk;

  	/* Only used for large blocks: pointer to next larger size.  */
  	struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  	struct malloc_chunk* bk_nextsize;
	};

### Use-After-Free
Use-After-Free指的是在程序中，存在有p->object，但是在object被释放之后，p仍然被引用的情况。
	
### Overflow

### Vulnerbility
CTF训练 西普